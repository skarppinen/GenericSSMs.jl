var documenterSearchIndex = {"docs":
[{"location":"interface.html#Defining-SSMs-using-GenericSSMs.jl","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"","category":"section"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"For a quick reference to the information provided here, type ?GenericSSM in the Julia REPL after loading GenericSSMs.jl.","category":"page"},{"location":"interface.html#Overview","page":"Defining SSMs using GenericSSMs.jl","title":"Overview","text":"","category":"section"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"To use GenericSSMs.jl for the inference of an SSM, the user should define:","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"A model struct representing the SSM.\nMethods that implement the SSM.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Steps 1 and 2 above are described below.","category":"page"},{"location":"interface.html#Model-struct-and-the-abstract-type-GenericSSM","page":"Defining SSMs using GenericSSMs.jl","title":"Model struct and the abstract type GenericSSM","text":"","category":"section"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"The model struct is a normal Julia struct that represents a user-defined SSM.  The purpose of the model struct is to act as: ","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"a type for code selection using multiple dispatch, \na container for data and parameters related to the SSM.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"All model structs need to be defined as a subtype of GenericSSM, which is an abstract type exported by GenericSSMs.jl. Otherwise, the user is free to define the model struct as they see fit for their problem.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"As an example, to define an SSM named Model that has floating point observations, the following model struct could be used:","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"struct Model <: GenericSSM\n   y::Vector{Float64}\n   # .. arbitrary fields such as other data and parameters related to the SSM ..\nend","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Here, the fieldname y is an arbitrary choice.  Naturally, it is also possible to use type parameters in the definition of the model struct.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"There are two optional methods that the user may wish to overload for their model struct:","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"particle_type","category":"page"},{"location":"interface.html#GenericSSMs.particle_type","page":"Defining SSMs using GenericSSMs.jl","title":"GenericSSMs.particle_type","text":"particle_type(model::GenericSSM)\n\nReturn the particle type associated with the model model. There exists a fallback for this function, which calls M1 and checks the type of the output.\n\n\n\n\n\n","category":"function"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"observation_type","category":"page"},{"location":"interface.html#GenericSSMs.observation_type","page":"Defining SSMs using GenericSSMs.jl","title":"GenericSSMs.observation_type","text":"observation_type(model::GenericSSM)\n\nReturn the observation type associated with the model model. There exists a fallback for this function, which calls gk and checks the type of the output.\n\n\n\n\n\n","category":"function"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"As discussed above, both of these functions have fallbacks that work once the user defines  some of the methods discussed in the next section.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"The section Examples contains examples of model struct definitions for more concrete SSMs.","category":"page"},{"location":"interface.html#Methods-implementable-for-GenericSSMs","page":"Defining SSMs using GenericSSMs.jl","title":"Methods implementable for GenericSSMs","text":"","category":"section"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"After the model struct has been defined, the user should implement (at minimum a subset of, see Method definitions required by use case) methods that define ","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"the components (M_1n G_1n) of the Feynman-Kac model of interest\nthe components (m_1n g_1n) of the underlying SSM.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"The interface below gives the method signatures for all implementable methods in GenericSSMs.jl, with","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Model <: GenericSSM standing for the type of a user-defined model struct,\nP standing for any (particle) type,\nF standing for a floating point type, i.e F <: AbstractFloat,\nY standing for any (observation) type, \nthe rng argument reserved for a generic random number generator.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"interface: All implementable methods in the GenericSSMs.jl interface for Model <: GenericSSM\nM1(model::Model, rng)::P should return a simulated draw from M_1(cdot).\nlogG1(model::Model, x::P)::F should return log(G_1(x)) in mathbbR.\nMk(model::Model, x::P, k::Integer, rng)::P should return a simulated draw from M_k(cdot mid x) k geq 2. \nlogGk(model::Model, x::P, y::P, k::Integer)::F should return log(G_k(x y)) in mathbbR k geq 2.\nlogM1(model::Model, x::P)::F should return log(M_1(x)) in mathbbR.\nlogMk(model::Model, y::P, x::P, k::Integer)::F should return log(M_k(y mid x)) in mathbbR k geq 2.\nm1(model::Model, rng)::P should return a simulated draw from m_1(cdot).\nmk(model::Model, x::P, k::Integer, rng)::P should return a simulated draw from m_k(cdot mid x) k geq 2.\ngk(model::Model, x::P, k::Integer, rng)::Y should return a simulated draw from g_k(cdot mid x) k geq 1.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"note: In the above interface:\nThe first argument in each method signature is used to distinguish the methods of separate SSMs. \nMk, logGk, logMk and mk should be defined for k geq 2. The cases k = 1 should be implemented by the separate functions M1, logG1, logM1 and m1. This is necessary since the mathematical function signatures for the cases k geq 2 and k = 1 differ. \nThe order of the arguments x and y in the signatures of logGk and logMk are reversed, again for consistency with the mathematical notation.\nThe methods are not exported by GenericSSMs.jl. When defining them, their names should be qualified by GenericSSMs.","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"See the Examples section for examples of defining the above methods for concrete SSMs.","category":"page"},{"location":"interface.html#Method-definitions-required-by-use-case","page":"Defining SSMs using GenericSSMs.jl","title":"Method definitions required by use case","text":"","category":"section"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"The user need not define all methods in the interface of GenericSSMs.jl, but may instead define the part of the interface that is needed for their use case.  The following table displays the required functions for each use case of GenericSSMs.jl. ","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Use case M1 logG1 Mk logGk logM1 logMk m1 mk gk\nParticle filtering x x x x     \nCPF (with ancestor tracing) x x x x     \nCPF (with backward sampling) x x x x  x   \nPrediction at state level x x x x   x x \nPrediction at observation level x x x x   x x x\nSimulation at state level       x x \nSimulation at observation level       x x x","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Note that logM1 is currently not required for any use case, but is included in GenericSSMs.jl since it is required by some particle filtering algorithms (such as the particle Gibbs algorithm). ","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"note: Note\nA MethodError will be thrown if a particular method needed by a use case is not defined when the respective algorithm is invoked.","category":"page"},{"location":"interface.html#Unicode-method-aliases","page":"Defining SSMs using GenericSSMs.jl","title":"Unicode method aliases","text":"","category":"section"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"GenericSSMs.jl also supports more aesthetically pleasing aliases that can be used instead of the above method names.  The following table lists them: ","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Function Alias\nM1 M₁\nMk Mₖ\nlogG1 logG₁\nlogGk logGₖ\nlogM1 logM₁\nlogMk logMₖ\nm1 m₁\nmk mₖ\ngk gₖ","category":"page"},{"location":"interface.html","page":"Defining SSMs using GenericSSMs.jl","title":"Defining SSMs using GenericSSMs.jl","text":"Type \\_1[Tab] and \\_k[Tab] (where [Tab] is a Tab press) in the Julia REPL to write ₁ and ₖ, respectively.","category":"page"},{"location":"use-cases.html#Using-GenericSSMs.jl","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"","category":"section"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"This section discusses how to use GenericSSMs.jl for SSMs defined as discussed in Section Defining SSMs using GenericSSMs.jl.","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Most of the methods exported by GenericSSMs.jl do not (heap) allocate memory, but instead operate on storage objects, such that a typical method call (in this case to a method named operation) takes the form: ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"operation!(storage, ... additional arguments ...)","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The object storage is simply an object that collects all pre-allocated memory necessary for making a particular computation (such as particle filtering or predicting). There are also `allocating versions` (lacking the exclamation mark) of some of the functionality, but the non-allocating versions should be used for performance especially in situations where a particular method needs to called multiple times (see Julia performance tips: pre-allocating outputs).","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"There are three storage objects used in GenericSSMs.jl:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"PFStorage (for particle filtering)\nCPFStorage (for conditional particle filtering)\nPredictStorage (for prediction)","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"These are discussed below with their respective use cases. In what follows, we will in general use N to refer to the number of particles, and n to the number of time points (or length of the observed time series).","category":"page"},{"location":"use-cases.html#Particle-filtering","page":"Using GenericSSMs.jl","title":"Particle filtering","text":"","category":"section"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The particle filter implementation of GenericSSMs.jl can be invoked by calling pf_forward_pass!: ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"pf_forward_pass!(::PFStorage, ::GenericSSM, ::Any, ::Any)","category":"page"},{"location":"use-cases.html#GenericSSMs.pf_forward_pass!-Tuple{PFStorage, GenericSSM, Any, Any}","page":"Using GenericSSMs.jl","title":"GenericSSMs.pf_forward_pass!","text":"pf_forward_pass!(st::PFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])\n\nRun the standard particle filter for model model using storage st and resampling resampling that implements  resample! (see ?GenericSSMs.resample!).  An RNG may be specified as the last argument.\n\nThe return value is the logarithm of the normalising constant estimate of the particle filter.\n\n\n\n\n\n","category":"method"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"pf_forward_pass! populates its first argument, a PFStorage object, which has the following structure:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"PFStorage","category":"page"},{"location":"use-cases.html#GenericSSMs.PFStorage","page":"Using GenericSSMs.jl","title":"GenericSSMs.PFStorage","text":"A storage object used for standard particle filtering. The object contains all memory needed for particle filtering. \n\nType parameters:\n\nP: Particle type.\nF: Floating point type.\n\nFields:\n\nX::Matrix{P}, the N x n particle system of particles\nW::Matrix{F}, the N x n unnormalised logweight matrix,\nA::Matrix{Int}, the N x n - 1 ancestor index matrix.\n\nThe additional field _w is used internally for normalised weights (do not modify). The ancestor of the particle X[i, k] is X[A[i, k - 1], k - 1].\n\n\n\n\n\n","category":"type"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The easiest way to construct a PFStorage object is via the constructor:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"PFStorage(::GenericSSM, ::Integer, ::Integer; ::Type{<: AbstractFloat})","category":"page"},{"location":"use-cases.html#GenericSSMs.PFStorage-Tuple{GenericSSM, Integer, Integer}","page":"Using GenericSSMs.jl","title":"GenericSSMs.PFStorage","text":"PFStorage(model::GenericSSM, N::Integer, n::Integer; F::Type{<: AbstractFloat} = Float64)\n\nConstruct a storage object for standard particle filtering model model with N particles and time series length n. F may be used to set the floating point type.\n\nASSUMPTIONS:\n\nN >= 2, n >= 1 (checked, throws error)\n\n\n\n\n\n","category":"method"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The other arguments to pf_forward_pass! above are","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"the SSM model (expected to be defined as in Defining SSMs using GenericSSMs.jl)\nresampling object, that implements resample! from the resampling API of GenericSSMs.jl ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"For the latter, it is possible to use any resampling provided by Resamplings.jl (see Section Examples for examples of this).","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Finally, for convenience, pf_forward_pass! can also be called with a CPFStorage storage object (discussed in Conditional particle filtering), as follows:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"pf_forward_pass!(::CPFStorage, ::GenericSSM, ::Any, ::Any)","category":"page"},{"location":"use-cases.html#GenericSSMs.pf_forward_pass!-Tuple{CPFStorage, GenericSSM, Any, Any}","page":"Using GenericSSMs.jl","title":"GenericSSMs.pf_forward_pass!","text":"pf_forward_pass!(st::CPFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])\n\nAdditional method for pf_forward_pass! that allows running the standard particle filter with the CPFStorage storage object.  This method does not alter the field st.ref since it is not needed in standard particle filtering. \n\n\n\n\n\n","category":"method"},{"location":"use-cases.html#Conditional-particle-filtering","page":"Using GenericSSMs.jl","title":"Conditional particle filtering","text":"","category":"section"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The conditional particle filter (CPF) is otherwise similar to the (standard) particle filter, but features a `reference trajectory` that is never mutated as the algorithm proceeds. Due to this, the CPF requires its own storage object, CPFStorage:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"CPFStorage","category":"page"},{"location":"use-cases.html#GenericSSMs.CPFStorage","page":"Using GenericSSMs.jl","title":"GenericSSMs.CPFStorage","text":"A storage object used for conditional particle filtering. The object contains all memory needed for conditional particle filtering.\n\nType parameters:\n\nP: Particle type.\nF: Floating point type.\n\nFields:\n\npfst::PFStorage{P, F}, the storage used for standard particle filtering (see ?PFStorage),\nref::Vector{Int}, a vector of length n that records which rows (elements) in each column of pfst.X currently hold the reference trajectory.\n\n\n\n\n\n","category":"type"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The construction of a CPFStorage object is similar to that of PFStorage:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"CPFStorage(::GenericSSM, ::Integer, ::Integer; ::Type{<: AbstractFloat})","category":"page"},{"location":"use-cases.html#GenericSSMs.CPFStorage-Tuple{GenericSSM, Integer, Integer}","page":"Using GenericSSMs.jl","title":"GenericSSMs.CPFStorage","text":"CPFStorage(model::GenericSSM, N::Integer, n::Integer; F::Type{<: AbstractFloat} = Float64)\n\nConstruct a storage object for conditional particle filtering model model with N particles and time series length n. F may be used to set the floating point type.\n\nASSUMPTIONS:\n\nN >= 2, n >= 1 (checked, throws error)\n\n\n\n\n\n","category":"method"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The main function for running the (forward) conditional particle filter is called cpf_forward_pass!:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"cpf_forward_pass!","category":"page"},{"location":"use-cases.html#GenericSSMs.cpf_forward_pass!","page":"Using GenericSSMs.jl","title":"GenericSSMs.cpf_forward_pass!","text":"cpf_forward_pass!(st::CPFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])\n\nRun the forward pass of the conditional particle filter using storage st for model model with resampling resampling that implements conditional_resample! (see ?GenericSSMs.conditional_resample!).  An RNG may be specified as the last argument.\n\nASSUMPTIONS:\n\nthe reference trajectory has been initialised to st (fields st.ref and st.pfst have been populated). Results output by this function WILL BE WRONG, if this has not been done. Use initialise_reference! to properly initialise reference. \n\n\n\n\n\n","category":"function"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Here, the resampling object must implement conditional_resample! from the resampling API of GenericSSMs.jl. Again, any conditional resampling from Resamplings.jl may be used.","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Note that care must be taken to ensure that the reference trajectory has been initialised to a sensible value before calling cpf_forward_pass!. For the first run of cpf_forward_pass!, a straightforward way to do this is to call initialise_reference! which uses the standard particle filter to initialise the reference:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"initialise_reference!","category":"page"},{"location":"use-cases.html#GenericSSMs.initialise_reference!","page":"Using GenericSSMs.jl","title":"GenericSSMs.initialise_reference!","text":"initialise_reference!(st::CPFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])\n\nInitialise the reference trajectory for running the conditional particle filter forward pass (cpf_forward_pass!).\n\n\n\n\n\n","category":"function"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"To do the CPF backward pass, the function traceback! can be used, with either AncestorTracing or BackwardSampling.  This effectively records a new reference trajectory to CPFStorage. ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"traceback!(::CPFStorage, ::Any, ::Type{AncestorTracing})\ntraceback!(::CPFStorage, ::Type{AncestorTracing})","category":"page"},{"location":"use-cases.html#GenericSSMs.traceback!-Tuple{CPFStorage, Any, Type{AncestorTracing}}","page":"Using GenericSSMs.jl","title":"GenericSSMs.traceback!","text":"traceback!(st::CPFStorage, model::GenericSSM, AncestorTracing[, rng = Random.GLOBAL_RNG])\n\nPopulate the reference indices st.ref using ancestor tracing.  To obtain the concrete reference trajectory values, use get_reference!.\n\nASSUMPTIONS:\n\nthe forward pass (pf_forward_pass! or cpf_forward_pass!) has been run before invoking this function and the contents of st have not changed after that. The results from this function WILL BE WRONG, if this is not the case. \n\n\n\n\n\n","category":"method"},{"location":"use-cases.html#GenericSSMs.traceback!-Tuple{CPFStorage, Type{AncestorTracing}}","page":"Using GenericSSMs.jl","title":"GenericSSMs.traceback!","text":"traceback!(st::CPFStorage, AncestorTracing[, rng = Random.GLOBAL_RNG])\n\nConvenience method for traceback using ancestor tracing (model not needed by ancestor tracing).\n\nASSUMPTIONS:\n\nthe forward pass (pf_forward_pass! or cpf_forward_pass!) has been run before invoking this function and the contents of st have not changed after that. The results from this function WILL BE WRONG, if this is not the case. \n\n\n\n\n\n","category":"method"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"traceback!(::CPFStorage, ::GenericSSM, ::Type{BackwardSampling})","category":"page"},{"location":"use-cases.html#GenericSSMs.traceback!-Tuple{CPFStorage, GenericSSM, Type{BackwardSampling}}","page":"Using GenericSSMs.jl","title":"GenericSSMs.traceback!","text":"traceback!(st::CPFStorage, model::GenericSSM, BackwardSampling[, rng = Random.GLOBAL_RNG])\n\nPopulate reference indices st.ref using backward sampling after running the forward pass, that is, pf_forward_pass! or cpf_forward_pass!. To obtain the concrete reference trajectory values, see get_reference!.\n\nASSUMPTIONS:\n\nthe forward pass (pf_forward_pass! or cpf_forward_pass!) has been run before invoking this function and the contents of st have not changed after that. The results from this function WILL BE WRONG, if this is not the case. \n\n\n\n\n\n","category":"method"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The function get_reference! may be used to read the concrete value of the reference trajectory to a vector of appropriate type and length:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"get_reference!","category":"page"},{"location":"use-cases.html#GenericSSMs.get_reference!","page":"Using GenericSSMs.jl","title":"GenericSSMs.get_reference!","text":"get_reference!(x::AbstractVector{P}, st::CPFStorage{P})\n\nRead the concrete reference trajectory to x from st.\n\nASSUMPTIONS:\n\ntraceback! has been run before invoking this function and the contents of st have not changed after that. The results from this function WILL BE WRONG, if this has not been done.\nlength(x) == length(st) (checked, throws error)\n\n\n\n\n\n","category":"function"},{"location":"use-cases.html#Unconditional-simulation-and-prediction-from-SSMs","page":"Using GenericSSMs.jl","title":"Unconditional simulation and prediction from SSMs","text":"","category":"section"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"GenericSSMs.jl provides functionality for unconditional simulation and prediction from generic SSMs at state and/or observation levels. The level at which simulation or prediction should be performed, is indicated by using a parametric type Level:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Level","category":"page"},{"location":"use-cases.html#GenericSSMs.Level","page":"Using GenericSSMs.jl","title":"GenericSSMs.Level","text":"Level{:state}, Level{:observation}, Level{(:state, :observation)}\n\nA struct tag (struct with no fields) representing the level (state level or observation level) at which simulation or prediction should be carried out. This type is used in the functions related to simulating and predicting (functions simulate!/simulate and predict!/predict).\n\nFor example, using Level{:state} in the aforementioned functions yields predictions/simulations at the state level, and using Level{:observation} yields them at the observation level. Level{(:state, :observation)} or Level{(:observation, :state)} yields predictions/simulations at both levels simultaneously. Note that :observation may be shortened to :obs. \n\n\n\n\n\n","category":"type"},{"location":"use-cases.html#Unconditional-simulation","page":"Using GenericSSMs.jl","title":"Unconditional simulation","text":"","category":"section"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Unconditional simulation means simulating a continuous slice of states x_l x_l+1 ldots x_u from the prior of x_lu,  where l  u and l geq 1 such that the initial state x_l is given as an argument. Similarly, a continuous slice of observations y_lu may be drawn. (see below) This functionality is achieved by the following allocating and nonallocating versions of simulate. By default, l = 1 and x_1 is first drawn from m_1 and then conditioned on when simulating x_2 ldots x_u, but this may be changed with the argument initial:  ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"simulate","category":"page"},{"location":"use-cases.html#GenericSSMs.simulate","page":"Using GenericSSMs.jl","title":"GenericSSMs.simulate","text":"simulate(n::Integer, model::GenericSSM, ::Type{L <: Level}                [, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))])\n\nReturn a vector of length n, dest, by simulating at level L from model model.  L specifies the level at which simulations should be carried out, and may be set to one of Level{:state}, Level{:observation}, Level{(:state, :observation)} (with possible abbreviations, see ?Level) which results in simulations at state, observation or state and observation levels, respectively.  In the final case, each simulated value corresponds to a tuple of the form (p, o), where p is a simulated particle value, and o a simulated observation simulated given p.\n\nThe value initial = (k, x) specifies that the time index associated with dest[1] should be k, and that the state value associated with dest[1] is x. Indeed, if states are simulated x is placed to dest[1]. The default of initial corresponds to (1, m1(model, rng)) meaning that simulation begins from the first time index.  See simulate! for in place version.\n\nREQUIRES:\n\nm1, mk, gk from the GenericSSMs interface (see ?GenericSSM) depending on input L. \n\n\n\n\n\n","category":"function"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"simulate!","category":"page"},{"location":"use-cases.html#GenericSSMs.simulate!","page":"Using GenericSSMs.jl","title":"GenericSSMs.simulate!","text":"simulate!(dest::AbstractVector{P}, model::GenericSSM, Level{:state}[, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))]) \n\nFill dest by simulating states from model model. \n\nThe value initial = (k, x) specifies:\n\nthat x should be placed to dest[1], \nthat the remaining elements in indices 2:length(dest) of dest should be simulated from mj where j in (k + 1):(k + length(dest) - 1).\n\nThe default of initial corresponds to (1, m1(model, rng)) meaning that the function returns a draw of state values at time indices 1:length(dest).  See simulate for allocating version.\n\nREQUIRES:\n\nm1 and mk from the GenericSSMs interface (see ?GenericSSM).\n\n\n\n\n\nsimulate!(dest::AbstractVector{Y}, model::GenericSSM, Level{:observation}[, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))]) \n\nFill dest by simulating observations from model model. \n\nThe value initial = (k, x) specifies:\n\nthat x is the state that is conditioned on when simulating the first observation to dest[1], \nthat the remaining observations in indices 2:length(dest) of dest should be simulated conditional on states simulated from mj where j in (k + 1):(k + length(dest) - 1).\n\nThe default of initial corresponds to (1, m1(model, rng)) meaning that the function returns a draw of observations at time indices 1:length(dest). See simulate for allocating version.\n\nREQUIRES:\n\nm1, mk and gk from the GenericSSMs interface (see ?GenericSSM). \n\n\n\n\n\nsimulate!(dest::AbstractVector{Tuple{P, Y}}, model::GenericSSM, Level{(:state, :observation)}[, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))]) \n\nFill dest by simulating states and observations from model model. \n\nThe value initial = (k, x) specifies:\n\nthat x should be placed to dest[1][1], \nthat the remaining elements in indices 2:length(destx) of dest should be simulated from mj and gj where j in (k + 1):(k + length(dest) - 1).\n\nThe default of initial corresponds to (1, m1(model, rng)) meaning that the function returns a draw of states and observations at time indices 1:length(dest).  See simulate for allocating version.\n\nREQUIRES:\n\nm1, mk and gk from the GenericSSMs interface (see ?GenericSSM).\n\n\n\n\n\n","category":"function"},{"location":"use-cases.html#Prediction","page":"Using GenericSSMs.jl","title":"Prediction","text":"","category":"section"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Prediction means simulating from the posterior distribution of future states pi(x_n+1n+h mid y_1n) or observations pi(y_n+1n+h mid y_1n) for some prediction horizon h geq 1. Prediction requires that the particle filter has been run.  The current implementation of prediction draws particles from the final particle approximation returned by the particle filter using stratified resampling and then simulates future state and/or observation trajectories given the chosen particles.","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The allocating version of predict takes the form: ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"predict","category":"page"},{"location":"use-cases.html#GenericSSMs.predict","page":"Using GenericSSMs.jl","title":"GenericSSMs.predict","text":"predict(st::PFStorage, newmodel::GenericSSM[, L = Level{:state}, rng = Random.GLOBAL_RNG]; nahead::Integer, nsim::Integer)::PredictStorage\n\nPredict nahead steps ahead using nsim simulations at level L (see ?Level). st should be a PFStorage object that contains results of particle filtering n time steps (see below). newmodel should be a model struct that contains the data (if any) necessary in making the future predictions.  In particular, if newmodel contains data indexed by time in the definition of mk, this function requires that said data must be indexable at the future indices n + 1, n + 2, ..., n + nahead, where n = length(st), that is, the number of time points that have been filtered. (otherwise a bounds error is thrown if bounds checking is not disabled in the definition of mk by the user) To this end, the Julia package OffsetArrays.jl offers convenient ways of defining arrays whose indexing may be offset by n (upon construction of newmodel).\n\nThe return value is an object of type PredictStorage (see ?PredictStorage), containing the simulations. See predict! for non-allocating version of this function.\n\nREQUIRES:\n\nmk and gk from the GenericSSMs interface (see ?GenericSSM), depending on the value of L.\n\nASSUMPTIONS:\n\npf_forward_pass! has been run with st as the first argument. Results WILL BE WRONG if this is not the case.\n\n\n\n\n\n","category":"function"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Prediction may also be carried out in a non-allocating fashion, by first explicitly constructing a PredictStorage object: ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"PredictStorage","category":"page"},{"location":"use-cases.html#GenericSSMs.PredictStorage","page":"Using GenericSSMs.jl","title":"GenericSSMs.PredictStorage","text":"PredictStorage{S, P, L, F}\n\nA storage object needed for performing predictions at state, observation or state and observation level. \n\nType parameters:\n\nS is the type of predicted values (either the particle type, observation type or tuple consisting of the particle type and observation type).\nP is the particle type.\nL is the level associated with the prediction storage.\nF is a floating point type.\n\nFields:\n\nX::Matrix{S}: An nahead x nsim matrix for storing nsim simulated trajectories nahead steps ahead from n.\nx::Vector{P}: The initial particles at time n.\nw::Vector{F}: The normalised weights of the initial particles x.\nn::Int: The time index associated with the weighted particles (x, w).\n_u::Vector{F}, _ind::Vector{Int}: Temporaries used in predicting (best left untouched).\n\n\n\n\n\n","category":"type"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The easiest way to do this is via the constructor:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"PredictStorage(::PFStorage, ::GenericSSM, ::Type{<:Level}; ::Integer, ::Integer, ::Integer)  ","category":"page"},{"location":"use-cases.html#GenericSSMs.PredictStorage-Tuple{PFStorage, GenericSSM, Type{<:Level}}","page":"Using GenericSSMs.jl","title":"GenericSSMs.PredictStorage","text":"PredictStorage(st::PFStorage, model::GenericSSM, L::Type{<: Level};                      nahead::Integer, nsim::Integer, n::Integer = length(st))\n\nConstruct a PredictStorage object from st and model at level L. Specifically reserve memory for predicting nahead steps ahead using nsim simulations and starting at timepoint n of the storage st.\n\nASSUMPTIONS: \n\nn is less than or equal to the length of st (checked, throws error)\npf_forward_pass! has been run for st beforehand.\n\n\n\n\n\n","category":"method"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Note that changing the argument n above to a value less than length(st) implicitly assumes that ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"\tpi(x_1n mid y_1n) propto M_1(x_1)G_1(x_1) prod_k = 2^n M_k(x_k mid x_k-1) G_k(x_k-1 x_k)  text for all  x_1n","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"holds also for this new value of n (and not only for n = length(st) as discussed in Feynman-Kac representation of an SSM). ","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"Then, predict! can be called with the storage object as the first argument:","category":"page"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"predict!","category":"page"},{"location":"use-cases.html#GenericSSMs.predict!","page":"Using GenericSSMs.jl","title":"GenericSSMs.predict!","text":"predict!(st::PredictStorage, newmodel::GenericSSM[, rng = Random.GLOBAL_RNG])\n\nPredict in place to storage st using model newmodel. The prediction is done at the level at which st was constructed. (see ?PredictStorage)\n\nnewmodel should be a model struct that contains the data (if any) necessary in making the future predictions.  In particular, if newmodel contains data indexed by time in the definition of mk, this function requires that said data must be indexable at the future indices n + 1, n + 2, ..., n + size(st, 1) at which predictions are requested.  (otherwise a bounds error is thrown if bounds checking is not disabled in the definition of mk by the user)\n\nTo this end, the Julia package OffsetArrays.jl offers convenient ways of defining arrays whose indexing may be offset by n (upon construction of newmodel). See predict for allocating versions of this function.\n\nREQUIRES: mk and gk from the GenericSSMs interface (see ?GenericSSM), depending on the value of L.\n\n\n\n\n\n","category":"function"},{"location":"use-cases.html","page":"Using GenericSSMs.jl","title":"Using GenericSSMs.jl","text":"The prediction results can then be obtained from the PredictStorage object written to.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html#Noisy-AR(1)-model","page":"Examples","title":"Noisy AR(1) model","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The following example showcases the main features of GenericSSMs.jl for  a simple state-space model called the \"noisy AR(1) model\":","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"\tbeginaligned\n\tx_1 sim N(0 sigma_1^2) \n\tx_k sim N(rho x_k-1 sigma_x^2)  text for  k geq 2 \n\ty_k sim N(x_k sigma_y^2)  text for  k geq 1 \n\tendaligned","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"with parameters theta = (sigma_1 sigma_x sigma_y rho).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using GenericSSMs\nusing Resamplings # For resampling algorithms.\nusing Random\nusing Distributions\n\n### Model struct definition.\n# - y: observed data points.\n# - θ: values of parameters.\nstruct NoisyarModel{ParamType} <: GenericSSM\n   y::Vector{Float64}\n   θ::ParamType\nend\n\n# Construct an instance of model struct with observed data\n# and desired parameters. Here, could also use a mutable container\n# for parameters, if need be.\ny = [1.0, 2.0, 3.0];\nθ = (σx = 1.0, σy = 1.0, ρ = 0.8, σ1 = 1.0); \nmodel = NoisyarModel(y, θ); # Instance of model.\n\n### Running particle filter. \n# First define enough of the interface to run PF.\n# NOTE: `(; ...) = model` accesses fields of `model`.\nfunction GenericSSMs.M1(model::NoisyarModel, rng)::Float64\n   (; θ) = model;\n   rand(rng, Normal(0.0, θ.σ1));\nend\t\nfunction GenericSSMs.logG1(model::NoisyarModel, x::Float64)\n   (; θ, y) = model;\n   logpdf(Normal(x, θ.σy), y[1]);\nend\nfunction GenericSSMs.Mk(model::NoisyarModel, prev::Float64, k::Integer, rng)\n   (; θ, y) = model; \n   rand(rng, Normal(prev, θ.σx));\nend\nfunction GenericSSMs.logGk(model::NoisyarModel, prev::Float64, cur::Float64, k::Integer)\n   (; θ, y) = model;\n   logpdf(Normal(cur, θ.σy), y[k]);\nend\nN = 16; # Number of particles.\nn = length(y); # Number of time points.\n\n# Define resampling (this uses Resamplings.jl)\nresampling = SystematicResampling(N; order = :none, randomisation = :none);\n\n# Allocate storage object for particle filtering. \nstorage = PFStorage(model, N, n);  \n\n# Set RNG. (optional)\nrng = Xoshiro(256);\n\n# Run particle filter. \npf_forward_pass!(storage, model, resampling); # Using GLOBAL_RNG.\npf_forward_pass!(storage, model, resampling, rng); # Using specified `rng`.\n\n### Running conditional particle filter (CPF).\n# Define more of the interface in order to be able to do CPF.\nfunction GenericSSMs.logMk(model::NoisyarModel, cur::Float64, prev::Float64, k::Integer)\n   (; θ) = model;\n   logpdf(Normal(θ.rho * prev, θ.σx), cur);\nend\n# Create storage object.\nstorage = CPFStorage(model, N, n);\n\n# Define conditional resampling (uses Resamplings.jl).\nresampling = SystematicResampling(N; intent = :conditional);\n\n# Initialise reference trajectory for CPF (with or without rng).\ninitialise_reference!(storage, model, resampling);\ninitialise_reference!(storage, model, resampling, rng);\n\n# Do CPF forward pass + ancestor trace.\ncpf_forward_pass!(storage, model, resampling, rng)\n\n# Traceback using ancestor tracing.\ntraceback!(storage, model, AncestorTracing); # .. or just `traceback!(storage, AncestorTracing)`\n\n# Read reference trajectory from storage.\nP = particle_type(model);\ntraj = Vector{P}(undef, length(storage));\nget_reference!(traj, storage); # `traj` is written to.\n\n# Do CPF forward pass + backward sampling.\ninitialise_reference!(storage, model, resampling, rng);\ncpf_forward_pass!(storage, model, resampling, rng);\ntraceback!(storage, model, BackwardSampling); \nget_reference!(traj, storage);\n\n### Unconditional simulation.\n# Let's define more of the interface to be able to simulate.\n# Note that for the particular Feynman-Kac model used, `m1` and `mk`\n# may be defined in terms of `M1` and `Mk` but in general this is not the case.\nfunction GenericSSMs.m1(model::NoisyarModel, rng)\n   GenericSSMs.M1(model, rng);\nend\nfunction GenericSSMs.mk(model::NoisyarModel, prev::Float64, k::Integer, rng)\n   GenericSSMs.Mk(model, prev, k, rng);\nend\nfunction GenericSSMs.gk(model::NoisyarModel, cur::Float64, k::Integer, rng)\n   (; θ) = model;\n   rand(rng, Normal(cur, θ.σy));\nend\n\n# Simulate 10 states / observations / states and observations \ndest = simulate(10, model, Level{:state});\ndest = simulate(10, model, Level{:obs});\ndest = simulate(10, model, Level{(:state, :obs)});\n\n# Simulation using preallocated vectors. \ndest = Vector{Float64}(undef, 10);\nsimulate!(dest, model, Level{:state});\nsimulate!(dest, model, Level{:state}, rng);\n\ndest = Vector{Float64}(undef, 10);\nsimulate!(dest, model, Level{:obs});\nsimulate!(dest, model, Level{:obs}, rng);\n\ndest = Vector{Tuple{Float64, Float64}}(undef, 10);\nsimulate!(dest, model, Level{(:state, :obs)});\nsimulate!(dest, model, Level{(:state, :obs)}, rng);\n\n### Prediction.\nstorage = PFStorage(model, N, n); # First define storage.\n\n# Run PF to initialise `storage` for prediction.\npf_forward_pass!(storage, model, resampling, rng); \n\n# Then do prediction (at different levels, with or without rng):\npredst = predict(storage, model, Level{(:state, :obs)}; nahead = 10, nsim = 2000)\npredst = predict(storage, model, Level{:state}; nahead = 10, nsim = 2000)\npredst = predict(storage, model, Level{:obs}; nahead = 10, nsim = 2000)\npredst = predict(storage, model; nahead = 10, nsim = 2000);\npredst = predict(storage, model, Level{(:state, :obs)}, rng; nahead = 10, nsim = 2000)\npredst = predict(storage, model, Level{:state}, rng; nahead = 10, nsim = 2000)\npredst = predict(storage, model, Level{:obs}, rng; nahead = 10, nsim = 2000)\n\n# Prediction with preallocated PredictStorage. `n` stands for time index at which to start.\npredst = PredictStorage(storage, model, Level{:obs}; nahead = 10, nsim = 2000, n = 3);\npredict!(predst, model);\npredict!(predst, model, rng);\npredst = PredictStorage(storage, model, Level{:state}; nahead = 10, nsim = 2000);\npredict!(predst, model);\npredict!(predst, model, rng);\npredst = PredictStorage(storage, model, Level{(:state, :obs)}; nahead = 10, nsim = 2000, n = 1);\npredict!(predst, model);\npredict!(predst, model, rng);","category":"page"},{"location":"resampling-api.html#Resampling-API","page":"Resampling API","title":"Resampling API","text":"","category":"section"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"This section describes the resampling API of GenericSSMs.jl and is intended for users who wish to use their own resampling algorithm with GenericSSMs.jl. Otherwise, the resampling algorithms of Resamplings.jl implement the required  functionality and can be directly used with GenericSSMs.jl.","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"For particle filtering (pf_forward_pass!), the resampling object should implement:","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"resample!(resampling, ind::AbstractVector{<: Integer}, \n          w::AbstractVector{<: AbstractFloat}, rng)::Nothing","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"resample! should draw ancestor indices to ind given normalised weights w.  Note that length(ind) == length(w)` should hold. The last argument is preserved for a random number generator.","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"For conditional particle filtering (cpf_forward_pass!), the resampling object should implement: ","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"conditional_resample!(resampling, ind::AbstractVector{<: Integer}, \n                      w::AbstractVector{<: AbstractFloat}, \n                      k::Integer, i:::Integer, rng)::Nothing","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"conditional_resample! should draw ancestor indices to ind given normalised weights w and the condition that ind[k] = i. Again, length(ind) == length(w) should hold, and additionally, w[i] should be strictly positive. The last argument is preserved for a random number generator.","category":"page"},{"location":"resampling-api.html","page":"Resampling API","title":"Resampling API","text":"In general the resampling object can be of any type (and naturally contain arbitrary fields), as long as it satisfies the above API. It may be useful to look at the documentation and source code of Resamplings.jl for examples.","category":"page"},{"location":"ssms.html#State-space-models-and-Feynman-Kac-representations","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"","category":"section"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"This section gives a (very brief) introduction to state-space models and their Feynman-Kac representations, and introduces some notation used in the documentation of GenericSSMs.jl.","category":"page"},{"location":"ssms.html#State-space-models","page":"State-space models and Feynman-Kac representations","title":"State-space models","text":"","category":"section"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"State-space models (SSMs) are a broad class of statistical models for modelling multivariate time series data. Suppose that we are interested in modelling a p-dimensional time series of n observations, y_1n = y_1 y_2 ldots y_n.  SSMs assume that y_1n are generated conditional on a latent (unknown) state process, x_1n = x_1 x_2 ldots x_n whose dynamics form a Markov process.  A state-space model can thus be written in the following form:","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"\tbeginaligned\n\ttextState processequation \n\t\tx_1 sim m_1(cdot) \n\t\tx_k sim m_k(cdot mid x_k-1)  text for  k geq 2 \n\ttextObservation processequation \n\t\ty_k sim g_k(cdot mid x_k)  text for  k geq 1 \n\tendaligned","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"where:","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"m_1 is the distribution of the first latent state, x_1.\nm_k(cdot mid x_k-1) for k geq 2 are Markov transitions of the latent state, and\ng_k(y_k mid x_k) for k geq 1 are densities of the observations y_k given the state x_k.","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"In summary, the probability distributions m_k k geq 1 constitute the dynamics of the latent state process x_1n, and g_k k geq 1 describe how the (known) observations are generated conditional on the state process. State-space modelling means designing the state variables x_1n, their dynamics m_1n and the observation densities g_1n such that the model comprised of these provides a sensible statistical model for the observed data y_1n.","category":"page"},{"location":"ssms.html#Computational-problem","page":"State-space models and Feynman-Kac representations","title":"Computational problem","text":"","category":"section"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"Assume for simplicity that m_k k geq 1 admit densities (although this assumption is necessary only for some of the functionality of GenericSSMs). Then, the joint density of the states x_1n and observations y_1n is given by:","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"\tpi(x_1n y_1n) = m_1(x_1)g_1(y_1 mid x_1)prod_k = 2^n m_k(x_k mid x_k-1) g_k(y_k mid x_k)","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"In the context of SSMs, the central computational problem is in the computation of various posterior distributions of the unknown latent states x_1n.  Indeed, GenericSSMs provides functionality for simulating from the following posterior distributions: ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"p(x_1k mid y_1k) text for some  k geq 1 (filtering distributions) \np(x_n + h mid y_1n) or p(y_n + h mid y_1n) for some h  0 (predictive distributions)\np(x_1n mid y_1n) (smoothing distribution)","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"Furthermore, the particle filter also gives access to an estimate of the normalising constant, p(y_1n).","category":"page"},{"location":"ssms.html#Feynman-Kac-representation-of-an-SSM","page":"State-space models and Feynman-Kac representations","title":"Feynman-Kac representation of an SSM","text":"","category":"section"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"In GenericSSMs.jl, SSMs are defined in terms of Feynman-Kac models [see Del Moral (2004), Chopin and Papaspiliopoulos (2020)]  that are alternative representations for SSMs. There are multiple possible Feynman-Kac models for a single (underlying) SSM.  The rationale for using Feynman-Kac models is that they provide a convenient abstraction over SSMs that is very well suited for generic programming. ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"A Feynman-Kac model expresses ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"\tpi(x_1n mid y_1n) propto m_1(x_1)g_1(y_1 mid x_1)prod_k = 2^n m_k(x_k mid x_k-1) g_k(y_k mid x_k)","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"of the underlying SSM (m_1n g_1n) in terms of `components` (M_1n G_1n), such that it is assumed that","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"\tpi(x_1n mid y_1n) propto M_1(x_1)G_1(x_1) prod_k = 2^n M_k(x_k mid x_k-1) G_k(x_k-1 x_k)  text for all  x_1n","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"The components (M_1n G_1n) consists of:","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"M_1, which is an (alternative) initial distribution for x_1 \nM_k for k geq 2 that are (alternative) Markov transitions of the state, and \nG_k for k geq 1 that are `potential functions` taking values in the non-negative reals. ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"In other words, the previous equation simply says that the joint distribution of a Feynman-Kac model must equal the joint posterior of the underlying SSM (up to a constant of proportionality). ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"Note that in the above we have again assumed that M_k admit densities (although this is not required by all algorithms of GenericSSMs.jl, see Method definitions required by use case).  In general, M_k should however be simulatable, and G_k should be evaluatable pointwise. ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"An example of a Feynman-Kac model (M_1n G_1n) for the SSM (m_1n g_1n) is given by the choice ","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"\tbeginaligned\n\t\tM_k = q_k \n\t\tG_k = dfracg_k m_kq_k \n\tendaligned","category":"page"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"where q_k is a `proposal distribution` for the states.  A special case of this Feynman-Kac model is the choice q_k = m_k, which yields the bootstrap filter of [Gordon, Salmond, Smith (1993)].","category":"page"},{"location":"ssms.html#References","page":"State-space models and Feynman-Kac representations","title":"References","text":"","category":"section"},{"location":"ssms.html","page":"State-space models and Feynman-Kac representations","title":"State-space models and Feynman-Kac representations","text":"Del Moral, P. (2004) Feynman-Kac Formulae. Springer.\nChopin, N., and Papaspiliopoulos, O. (2020) An introduction to sequential Monte Carlo. Springer.\nGordon, N. J., Salmond, D. J., and Smith, A. F. (1993) Novel approach to nonlinear/non-Gaussian Bayesian state estimation. IEE Proceedings F (Radar and Signal Processing). 140(2):107-113.","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"GenericSSMs.jl is a Julia package that provides building blocks for conducting statistical inference of state-space models (SSMs) using particle filters.  The package is designed to be small and modular, attempting to provide sensible and reasonably fast, non-allocating primitives for writing particle filtering algorithms. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"GenericSSMs.jl assumes that the user is somewhat familiar with state-space models and their Feynman-Kac representations. This documentation provides a very short introduction to these topics. The references therein can be used to find more information. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The main features of GenericSSMs.jl are:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"an interface for defining an SSM using a Feynman-Kac representation that may depend on arbitrary data and parameters (a \"generic SSM\")\nparticle filtering & conditional particle filtering [Andrieu, Doucet, Holenstein (2010)] for generic SSMs\ntracebacking strategies for the conditional particle filter: \nancestor tracing [Andrieu, Doucet, Holenstein (2010)]\nbackward sampling [Whiteley (2010)]\nunconditional simulation from generic SSMs at state and/or observation level\nprediction from generic SSMs at state and/or observation level\na generic resampling API for user-defined resampling algorithms\ndefault resampling algorithms are provided via Resamplings.jl","category":"page"},{"location":"index.html#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Andrieu, C., Doucet, A., and Holenstein, R. (2010) Particle Markov chain Monte Carlo methods. Journal of the Royal Statistical Society: Series B. 72(3):269-342.\nWhiteley, N. (2010) Discussion on \"Particle Markov chain Monte Carlo methods\". Journal of the Royal Statistical Society: Series B. 72(3):306-307.","category":"page"},{"location":"quick-start.html#Installation","page":"Installation & quick start","title":"Installation","text":"","category":"section"},{"location":"quick-start.html","page":"Installation & quick start","title":"Installation & quick start","text":"To install and use GenericSSMs.jl, run the following commands in the Julia REPL:","category":"page"},{"location":"quick-start.html","page":"Installation & quick start","title":"Installation & quick start","text":"# Install GenericSSMs and its dependency Resamplings (need to do only once).\nimport Pkg;\nPkg.add(url = \"https://github.com/skarppinen/Resamplings.jl\"); \nPkg.add(url = \"https://github.com/skarppinen/GenericSSMs.jl\"); \n\n# Load GenericSSMs. \nusing GenericSSMs","category":"page"},{"location":"quick-start.html#Quick-start","page":"Installation & quick start","title":"Quick start","text":"","category":"section"},{"location":"quick-start.html","page":"Installation & quick start","title":"Installation & quick start","text":"To define a simple bootstrap filter with GenericSSMs.jl, see the first example in Examples.","category":"page"}]
}
