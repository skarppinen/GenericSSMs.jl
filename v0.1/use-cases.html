<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using GenericSSMs.jl · GenericSSMs.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.svg" alt="GenericSSMs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">GenericSSMs.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="quick-start.html">Installation &amp; quick start</a></li><li><a class="tocitem" href="ssms.html">State-space models and Feynman-Kac representations</a></li><li><a class="tocitem" href="interface.html">Defining SSMs using GenericSSMs.jl</a></li><li class="is-active"><a class="tocitem" href="use-cases.html">Using GenericSSMs.jl</a><ul class="internal"><li><a class="tocitem" href="#Particle-filtering"><span>Particle filtering</span></a></li><li><a class="tocitem" href="#Conditional-particle-filtering"><span>Conditional particle filtering</span></a></li><li><a class="tocitem" href="#Unconditional-simulation-and-prediction-from-SSMs"><span>Unconditional simulation and prediction from SSMs</span></a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li><li><a class="tocitem" href="resampling-api.html">Resampling API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="use-cases.html">Using GenericSSMs.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="use-cases.html">Using GenericSSMs.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/skarppinen/GenericSSMs.jl/blob/main/docs/src/use-cases.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-GenericSSMs.jl"><a class="docs-heading-anchor" href="#Using-GenericSSMs.jl">Using GenericSSMs.jl</a><a id="Using-GenericSSMs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Using-GenericSSMs.jl" title="Permalink"></a></h1><p>This section discusses how to use GenericSSMs.jl for SSMs defined as discussed in Section <a href="interface.html">Defining SSMs using GenericSSMs.jl</a>.</p><p>Most of the methods exported by GenericSSMs.jl do not (heap) allocate memory, but instead operate on <code>storage</code> objects, such that a typical method call (in this case to a method named <code>operation</code>) takes the form: </p><pre><code class="nohighlight hljs">operation!(storage, ... additional arguments ...)</code></pre><p>The object <code>storage</code> is simply an object that collects all pre-allocated memory necessary for making a particular computation (such as particle filtering or predicting). There are also `allocating versions` (lacking the exclamation mark) of some of the functionality, but the non-allocating versions should be used for performance especially in situations where a particular method needs to called multiple times (see <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">Julia performance tips: pre-allocating outputs</a>).</p><p>There are three storage objects used in GenericSSMs.jl:</p><ul><li><code>PFStorage</code> (for particle filtering)</li><li><code>CPFStorage</code> (for conditional particle filtering)</li><li><code>PredictStorage</code> (for prediction)</li></ul><p>These are discussed below with their respective use cases. In what follows, we will in general use <code>N</code> to refer to the number of particles, and <code>n</code> to the number of time points (or length of the observed time series).</p><h2 id="Particle-filtering"><a class="docs-heading-anchor" href="#Particle-filtering">Particle filtering</a><a id="Particle-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-filtering" title="Permalink"></a></h2><p>The particle filter implementation of GenericSSMs.jl can be invoked by calling <code>pf_forward_pass!</code>: </p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.pf_forward_pass!-Tuple{PFStorage, GenericSSM, Any, Any}" href="#GenericSSMs.pf_forward_pass!-Tuple{PFStorage, GenericSSM, Any, Any}"><code>GenericSSMs.pf_forward_pass!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>pf_forward_pass!(st::PFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])</code></p><p>Run the standard particle filter for model <code>model</code> using storage <code>st</code> and resampling <code>resampling</code> that implements  <code>resample!</code> (see <code>?GenericSSMs.resample!</code>).  An RNG may be specified as the last argument.</p><p>The return value is the logarithm of the normalising constant estimate of the particle filter.</p></div></section></article><p><code>pf_forward_pass!</code> populates its first argument, a <code>PFStorage</code> object, which has the following structure:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.PFStorage" href="#GenericSSMs.PFStorage"><code>GenericSSMs.PFStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A storage object used for standard particle filtering. The object contains all memory needed for particle filtering. </p><p>Type parameters:</p><ul><li><code>P</code>: Particle type.</li><li><code>F</code>: Floating point type.</li></ul><p>Fields:</p><ul><li><code>X::Matrix{P}</code>, the <code>N</code> x <code>n</code> particle system of particles</li><li><code>W::Matrix{F}</code>, the <code>N</code> x <code>n</code> unnormalised logweight matrix,</li><li><code>A::Matrix{Int}</code>, the <code>N</code> x <code>n - 1</code> ancestor index matrix.</li></ul><p>The additional field <code>_w</code> is used internally for normalised weights (do not modify). The ancestor of the particle <code>X[i, k]</code> is <code>X[A[i, k - 1], k - 1]</code>.</p></div></section></article><p>The easiest way to construct a <code>PFStorage</code> object is via the constructor:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.PFStorage-Tuple{GenericSSM, Integer, Integer}" href="#GenericSSMs.PFStorage-Tuple{GenericSSM, Integer, Integer}"><code>GenericSSMs.PFStorage</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>PFStorage(model::GenericSSM, N::Integer, n::Integer; F::Type{&lt;: AbstractFloat} = Float64)</code></p><p>Construct a storage object for standard particle filtering model <code>model</code> with <code>N</code> particles and time series length <code>n</code>. <code>F</code> may be used to set the floating point type.</p><p>ASSUMPTIONS:</p><ul><li><code>N &gt;= 2</code>, <code>n &gt;= 1</code> (checked, throws error)</li></ul></div></section></article><p>The other arguments to <code>pf_forward_pass!</code> above are</p><ul><li>the SSM <code>model</code> (expected to be defined as in <a href="interface.html">Defining SSMs using GenericSSMs.jl</a>)</li><li><code>resampling</code> object, that implements <code>resample!</code> from the <a href="resampling-api.html">resampling API</a> of GenericSSMs.jl </li></ul><p>For the latter, it is possible to use any resampling provided by <a href="https://github.com/skarppinen/Resamplings.jl">Resamplings.jl</a> (see Section <a href="examples.html">Examples</a> for examples of this).</p><p>Finally, for convenience, <code>pf_forward_pass!</code> can also be called with a <code>CPFStorage</code> storage object (discussed in <a href="use-cases.html#Conditional-particle-filtering">Conditional particle filtering</a>), as follows:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.pf_forward_pass!-Tuple{CPFStorage, GenericSSM, Any, Any}" href="#GenericSSMs.pf_forward_pass!-Tuple{CPFStorage, GenericSSM, Any, Any}"><code>GenericSSMs.pf_forward_pass!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>pf_forward_pass!(st::CPFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])</code></p><p>Additional method for <code>pf_forward_pass!</code> that allows running the standard particle filter with the <code>CPFStorage</code> storage object.  This method does not alter the field <code>st.ref</code> since it is not needed in standard particle filtering. </p></div></section></article><h2 id="Conditional-particle-filtering"><a class="docs-heading-anchor" href="#Conditional-particle-filtering">Conditional particle filtering</a><a id="Conditional-particle-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-particle-filtering" title="Permalink"></a></h2><p>The conditional particle filter (CPF) is otherwise similar to the (standard) particle filter, but features a `reference trajectory` that is never mutated as the algorithm proceeds. Due to this, the CPF requires its own storage object, <code>CPFStorage</code>:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.CPFStorage" href="#GenericSSMs.CPFStorage"><code>GenericSSMs.CPFStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A storage object used for conditional particle filtering. The object contains all memory needed for conditional particle filtering.</p><p>Type parameters:</p><ul><li><code>P</code>: Particle type.</li><li><code>F</code>: Floating point type.</li></ul><p>Fields:</p><ul><li><code>pfst::PFStorage{P, F}</code>, the storage used for standard particle filtering (see <code>?PFStorage</code>),</li><li><code>ref::Vector{Int}</code>, a vector of length <code>n</code> that records which rows (elements) in each column of <code>pfst.X</code> currently hold the reference trajectory.</li></ul></div></section></article><p>The construction of a <code>CPFStorage</code> object is similar to that of <code>PFStorage</code>:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.CPFStorage-Tuple{GenericSSM, Integer, Integer}" href="#GenericSSMs.CPFStorage-Tuple{GenericSSM, Integer, Integer}"><code>GenericSSMs.CPFStorage</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>CPFStorage(model::GenericSSM, N::Integer, n::Integer; F::Type{&lt;: AbstractFloat} = Float64)</code></p><p>Construct a storage object for conditional particle filtering model <code>model</code> with <code>N</code> particles and time series length <code>n</code>. <code>F</code> may be used to set the floating point type.</p><p>ASSUMPTIONS:</p><ul><li><code>N &gt;= 2</code>, <code>n &gt;= 1</code> (checked, throws error)</li></ul></div></section></article><p>The main function for running the (forward) conditional particle filter is called <code>cpf_forward_pass!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.cpf_forward_pass!" href="#GenericSSMs.cpf_forward_pass!"><code>GenericSSMs.cpf_forward_pass!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cpf_forward_pass!(st::CPFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])</code></p><p>Run the forward pass of the conditional particle filter using storage <code>st</code> for model <code>model</code> with resampling <code>resampling</code> that implements <code>conditional_resample!</code> (see <code>?GenericSSMs.conditional_resample!</code>).  An RNG may be specified as the last argument.</p><p>ASSUMPTIONS:</p><ul><li>the reference trajectory has been initialised to <code>st</code> (fields <code>st.ref</code> and <code>st.pfst</code> have been populated). Results output by this function WILL BE WRONG, if this has not been done. Use <code>initialise_reference!</code> to properly initialise reference. </li></ul></div></section></article><p>Here, the <code>resampling</code> object must implement <code>conditional_resample!</code> from the <a href="resampling-api.html">resampling API</a> of GenericSSMs.jl. Again, any <em>conditional</em> resampling from <a href="https://github.com/skarppinen/Resamplings.jl">Resamplings.jl</a> may be used.</p><p>Note that care must be taken to ensure that the reference trajectory has been initialised to a sensible value before calling <code>cpf_forward_pass!</code>. For the first run of <code>cpf_forward_pass!</code>, a straightforward way to do this is to call <code>initialise_reference!</code> which uses the standard particle filter to initialise the reference:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.initialise_reference!" href="#GenericSSMs.initialise_reference!"><code>GenericSSMs.initialise_reference!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>initialise_reference!(st::CPFStorage, model::GenericSSM, resampling[, rng = Random.GLOBAL_RNG])</code></p><p>Initialise the reference trajectory for running the conditional particle filter forward pass (<code>cpf_forward_pass!</code>).</p></div></section></article><p>To do the CPF backward pass, the function <code>traceback!</code> can be used, with either <code>AncestorTracing</code> or <code>BackwardSampling</code>.  This effectively records a new reference trajectory to <code>CPFStorage</code>. </p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.traceback!-Tuple{CPFStorage, Any, Type{AncestorTracing}}" href="#GenericSSMs.traceback!-Tuple{CPFStorage, Any, Type{AncestorTracing}}"><code>GenericSSMs.traceback!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>traceback!(st::CPFStorage, model::GenericSSM, AncestorTracing[, rng = Random.GLOBAL_RNG])</code></p><p>Populate the reference indices <code>st.ref</code> using ancestor tracing.  To obtain the concrete reference trajectory values, use <code>get_reference!</code>.</p><p>ASSUMPTIONS:</p><ul><li>the forward pass (<code>pf_forward_pass!</code> or <code>cpf_forward_pass!</code>) has been run before invoking this function and the contents of <code>st</code> have not changed after that. The results from this function WILL BE WRONG, if this is not the case. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.traceback!-Tuple{CPFStorage, Type{AncestorTracing}}" href="#GenericSSMs.traceback!-Tuple{CPFStorage, Type{AncestorTracing}}"><code>GenericSSMs.traceback!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>traceback!(st::CPFStorage, AncestorTracing[, rng = Random.GLOBAL_RNG])</code></p><p>Convenience method for traceback using ancestor tracing (model not needed by ancestor tracing).</p><p>ASSUMPTIONS:</p><ul><li>the forward pass (<code>pf_forward_pass!</code> or <code>cpf_forward_pass!</code>) has been run before invoking this function and the contents of <code>st</code> have not changed after that. The results from this function WILL BE WRONG, if this is not the case. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.traceback!-Tuple{CPFStorage, GenericSSM, Type{BackwardSampling}}" href="#GenericSSMs.traceback!-Tuple{CPFStorage, GenericSSM, Type{BackwardSampling}}"><code>GenericSSMs.traceback!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>traceback!(st::CPFStorage, model::GenericSSM, BackwardSampling[, rng = Random.GLOBAL_RNG])</code></p><p>Populate reference indices <code>st.ref</code> using backward sampling after running the forward pass, that is, <code>pf_forward_pass!</code> or <code>cpf_forward_pass!</code>. To obtain the concrete reference trajectory values, see <code>get_reference!</code>.</p><p>ASSUMPTIONS:</p><ul><li>the forward pass (<code>pf_forward_pass!</code> or <code>cpf_forward_pass!</code>) has been run before invoking this function and the contents of <code>st</code> have not changed after that. The results from this function WILL BE WRONG, if this is not the case. </li></ul></div></section></article><p>The function <code>get_reference!</code> may be used to read the concrete value of the reference trajectory to a vector of appropriate type and length:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.get_reference!" href="#GenericSSMs.get_reference!"><code>GenericSSMs.get_reference!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_reference!(x::AbstractVector{P}, st::CPFStorage{P})</code></p><p>Read the concrete reference trajectory to <code>x</code> from <code>st</code>.</p><p>ASSUMPTIONS:</p><ul><li><code>traceback!</code> has been run before invoking this function and the contents of <code>st</code> have not changed after that. The results from this function WILL BE WRONG, if this has not been done.</li><li><code>length(x) == length(st)</code> (checked, throws error)</li></ul></div></section></article><h2 id="Unconditional-simulation-and-prediction-from-SSMs"><a class="docs-heading-anchor" href="#Unconditional-simulation-and-prediction-from-SSMs">Unconditional simulation and prediction from SSMs</a><a id="Unconditional-simulation-and-prediction-from-SSMs-1"></a><a class="docs-heading-anchor-permalink" href="#Unconditional-simulation-and-prediction-from-SSMs" title="Permalink"></a></h2><p>GenericSSMs.jl provides functionality for unconditional simulation and prediction from generic SSMs at state and/or observation levels. The level at which simulation or prediction should be performed, is indicated by using a parametric type <code>Level</code>:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.Level" href="#GenericSSMs.Level"><code>GenericSSMs.Level</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Level{:state}, Level{:observation}, Level{(:state, :observation)}</code></p><p>A struct tag (struct with no fields) representing the level (state level or observation level) at which simulation or prediction should be carried out. This type is used in the functions related to simulating and predicting (functions <code>simulate!/simulate</code> and <code>predict!/predict</code>).</p><p>For example, using <code>Level{:state}</code> in the aforementioned functions yields predictions/simulations at the state level, and using <code>Level{:observation}</code> yields them at the observation level. <code>Level{(:state, :observation)}</code> or <code>Level{(:observation, :state)}</code> yields predictions/simulations at both levels simultaneously. Note that <code>:observation</code> may be shortened to <code>:obs</code>. </p></div></section></article><h3 id="Unconditional-simulation"><a class="docs-heading-anchor" href="#Unconditional-simulation">Unconditional simulation</a><a id="Unconditional-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Unconditional-simulation" title="Permalink"></a></h3><p>Unconditional simulation means simulating a continuous slice of states <span>$x_{l}, x_{l+1}, \ldots, x_u$</span> from the prior of <span>$x_{l:u}$</span>,  where <span>$l &lt; u$</span> and <span>$l \geq 1$</span> such that the initial state <span>$x_l$</span> is given as an argument. Similarly, a continuous slice of observations <span>$y_{l:u}$</span> may be drawn. (see below) This functionality is achieved by the following allocating and nonallocating versions of <code>simulate</code>. By default, <span>$l = 1$</span> and <span>$x_1$</span> is first drawn from <span>$m_1$</span> and then conditioned on when simulating <span>$x_2, \ldots, x_u$</span>, but this may be changed with the argument <code>initial</code>:  </p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.simulate" href="#GenericSSMs.simulate"><code>GenericSSMs.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simulate(n::Integer, model::GenericSSM, ::Type{L &lt;: Level}                [, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))])</code></p><p>Return a vector of length <code>n</code>, <code>dest</code>, by simulating at level <code>L</code> from model <code>model</code>.  <code>L</code> specifies the level at which simulations should be carried out, and may be set to one of <code>Level{:state}, Level{:observation}, Level{(:state, :observation)}</code> (with possible abbreviations, see <code>?Level</code>) which results in simulations at state, observation or state and observation levels, respectively.  In the final case, each simulated value corresponds to a tuple of the form <code>(p, o)</code>, where <code>p</code> is a simulated particle value, and <code>o</code> a simulated observation simulated given <code>p</code>.</p><p>The value <code>initial = (k, x)</code> specifies that the time index associated with <code>dest[1]</code> should be <code>k</code>, and that the state value associated with <code>dest[1]</code> is <code>x</code>. Indeed, if states are simulated <code>x</code> is placed to <code>dest[1]</code>. The default of <code>initial</code> corresponds to <code>(1, m1(model, rng))</code> meaning that simulation begins from the first time index.  See <code>simulate!</code> for in place version.</p><p>REQUIRES:</p><ul><li><code>m1</code>, <code>mk</code>, <code>gk</code> from the GenericSSMs interface (see <code>?GenericSSM</code>) depending on input <code>L</code>. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.simulate!" href="#GenericSSMs.simulate!"><code>GenericSSMs.simulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>simulate!(dest::AbstractVector{P}, model::GenericSSM, Level{:state}[, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))])</code> </p><p>Fill <code>dest</code> by simulating states from model <code>model</code>. </p><p>The value <code>initial = (k, x)</code> specifies:</p><ol><li>that <code>x</code> should be placed to <code>dest[1]</code>, </li><li>that the remaining elements in indices <code>2:length(dest)</code> of <code>dest</code> should be simulated from <code>mj</code> where <code>j in (k + 1):(k + length(dest) - 1)</code>.</li></ol><p>The default of <code>initial</code> corresponds to <code>(1, m1(model, rng))</code> meaning that the function returns a draw of state values at time indices <code>1:length(dest)</code>.  See <code>simulate</code> for allocating version.</p><p>REQUIRES:</p><ul><li><code>m1</code> and <code>mk</code> from the GenericSSMs interface (see <code>?GenericSSM</code>).</li></ul></div></section><section><div><p><code>simulate!(dest::AbstractVector{Y}, model::GenericSSM, Level{:observation}[, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))])</code> </p><p>Fill <code>dest</code> by simulating observations from model <code>model</code>. </p><p>The value <code>initial = (k, x)</code> specifies:</p><ol><li>that <code>x</code> is the state that is conditioned on when simulating the first observation to <code>dest[1]</code>, </li><li>that the remaining observations in indices <code>2:length(dest)</code> of <code>dest</code> should be simulated conditional on states simulated from <code>mj</code> where <code>j in (k + 1):(k + length(dest) - 1)</code>.</li></ol><p>The default of <code>initial</code> corresponds to <code>(1, m1(model, rng))</code> meaning that the function returns a draw of observations at time indices <code>1:length(dest)</code>. See <code>simulate</code> for allocating version.</p><p>REQUIRES:</p><ul><li><code>m1</code>, <code>mk</code> and <code>gk</code> from the GenericSSMs interface (see <code>?GenericSSM</code>). </li></ul></div></section><section><div><p><code>simulate!(dest::AbstractVector{Tuple{P, Y}}, model::GenericSSM, Level{(:state, :observation)}[, rng = Random.GLOBAL_RNG; initial::Tuple{Integer, P} = (1, m1(model, rng))])</code> </p><p>Fill <code>dest</code> by simulating states and observations from model <code>model</code>. </p><p>The value <code>initial = (k, x)</code> specifies:</p><ol><li>that <code>x</code> should be placed to <code>dest[1][1]</code>, </li><li>that the remaining elements in indices <code>2:length(destx)</code> of <code>dest</code> should be simulated from <code>mj</code> and <code>gj</code> where <code>j in (k + 1):(k + length(dest) - 1)</code>.</li></ol><p>The default of <code>initial</code> corresponds to <code>(1, m1(model, rng))</code> meaning that the function returns a draw of states and observations at time indices <code>1:length(dest)</code>.  See <code>simulate</code> for allocating version.</p><p>REQUIRES:</p><ul><li><code>m1</code>, <code>mk</code> and <code>gk</code> from the GenericSSMs interface (see <code>?GenericSSM</code>).</li></ul></div></section></article><h3 id="Prediction"><a class="docs-heading-anchor" href="#Prediction">Prediction</a><a id="Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction" title="Permalink"></a></h3><p>Prediction means simulating from the posterior distribution of future states <span>$\pi(x_{n+1:n+h} \mid y_{1:n})$</span> or observations <span>$\pi(y_{n+1:n+h} \mid y_{1:n})$</span> for some prediction horizon <span>$h \geq 1$</span>. Prediction requires that the particle filter has been run.  The current implementation of prediction draws particles from the final particle approximation returned by the particle filter using stratified resampling and then simulates future state and/or observation trajectories given the chosen particles.</p><p>The allocating version of <code>predict</code> takes the form: </p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.predict" href="#GenericSSMs.predict"><code>GenericSSMs.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>predict(st::PFStorage, newmodel::GenericSSM[, L = Level{:state}, rng = Random.GLOBAL_RNG]; nahead::Integer, nsim::Integer)::PredictStorage</code></p><p>Predict <code>nahead</code> steps ahead using <code>nsim</code> simulations at level <code>L</code> (see <code>?Level</code>). <code>st</code> should be a <code>PFStorage</code> object that contains results of particle filtering <code>n</code> time steps (see below). <code>newmodel</code> should be a model struct that contains the data (if any) necessary in making the future predictions.  In particular, if <code>newmodel</code> contains data indexed by time in the definition of <code>mk</code>, this function requires that said data must be indexable at the future indices <code>n + 1, n + 2, ..., n + nahead</code>, where <code>n = length(st)</code>, that is, the number of time points that have been filtered. (otherwise a bounds error is thrown if bounds checking is not disabled in the definition of <code>mk</code> by the user) To this end, the Julia package <code>OffsetArrays.jl</code> offers convenient ways of defining arrays whose indexing may be offset by <code>n</code> (upon construction of <code>newmodel</code>).</p><p>The return value is an object of type <code>PredictStorage</code> (see <code>?PredictStorage</code>), containing the simulations. See <code>predict!</code> for non-allocating version of this function.</p><p>REQUIRES:</p><ul><li><code>mk</code> and <code>gk</code> from the GenericSSMs interface (see <code>?GenericSSM</code>), depending on the value of <code>L</code>.</li></ul><p>ASSUMPTIONS:</p><ul><li><code>pf_forward_pass!</code> has been run with <code>st</code> as the first argument. Results WILL BE WRONG if this is not the case.</li></ul></div></section></article><p>Prediction may also be carried out in a non-allocating fashion, by first explicitly constructing a <code>PredictStorage</code> object: </p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.PredictStorage" href="#GenericSSMs.PredictStorage"><code>GenericSSMs.PredictStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PredictStorage{S, P, L, F}</code></p><p>A storage object needed for performing predictions at state, observation or state and observation level. </p><p>Type parameters:</p><ul><li><code>S</code> is the type of predicted values (either the particle type, observation type or tuple consisting of the particle type and observation type).</li><li><code>P</code> is the particle type.</li><li><code>L</code> is the level associated with the prediction storage.</li><li><code>F</code> is a floating point type.</li></ul><p>Fields:</p><ul><li><code>X::Matrix{S}</code>: An <code>nahead x nsim</code> matrix for storing <code>nsim</code> simulated trajectories <code>nahead</code> steps ahead from <code>n</code>.</li><li><code>x::Vector{P}</code>: The initial particles at time <code>n</code>.</li><li><code>w::Vector{F}</code>: The normalised weights of the initial particles <code>x</code>.</li><li><code>n::Int</code>: The time index associated with the weighted particles <code>(x, w)</code>.</li><li><code>_u::Vector{F}, _ind::Vector{Int}</code>: Temporaries used in predicting (best left untouched).</li></ul></div></section></article><p>The easiest way to do this is via the constructor:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.PredictStorage-Tuple{PFStorage, GenericSSM, Type{&lt;:Level}}" href="#GenericSSMs.PredictStorage-Tuple{PFStorage, GenericSSM, Type{&lt;:Level}}"><code>GenericSSMs.PredictStorage</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>PredictStorage(st::PFStorage, model::GenericSSM, L::Type{&lt;: Level};                      nahead::Integer, nsim::Integer, n::Integer = length(st))</code></p><p>Construct a PredictStorage object from <code>st</code> and <code>model</code> at level <code>L</code>. Specifically reserve memory for predicting <code>nahead</code> steps ahead using <code>nsim</code> simulations and starting at timepoint <code>n</code> of the storage <code>st</code>.</p><p>ASSUMPTIONS: </p><ul><li><code>n</code> is less than or equal to the length of <code>st</code> (checked, throws error)</li><li><code>pf_forward_pass!</code> has been run for <code>st</code> beforehand.</li></ul></div></section></article><p>Note that changing the argument <code>n</code> above to a value less than <code>length(st)</code> implicitly assumes that </p><p class="math-container">\[	\pi(x_{1:n} \mid y_{1:n}) \propto M_1(x_1)G_1(x_1) \prod_{k = 2}^{n} M_k(x_k \mid x_{k-1}) G_k(x_{k-1}, x_k) \ \text{ for all } x_{1:n}.\]</p><p>holds also for this new value of <code>n</code> (and not only for <code>n = length(st)</code> as discussed in <a href="ssms.html#Feynman-Kac-representation-of-an-SSM">Feynman-Kac representation of an SSM</a>). </p><p>Then, <code>predict!</code> can be called with the storage object as the first argument:</p><article class="docstring"><header><a class="docstring-binding" id="GenericSSMs.predict!" href="#GenericSSMs.predict!"><code>GenericSSMs.predict!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>predict!(st::PredictStorage, newmodel::GenericSSM[, rng = Random.GLOBAL_RNG])</code></p><p>Predict in place to storage <code>st</code> using model <code>newmodel</code>. The prediction is done at the level at which <code>st</code> was constructed. (see <code>?PredictStorage</code>)</p><p><code>newmodel</code> should be a model struct that contains the data (if any) necessary in making the future predictions.  In particular, if <code>newmodel</code> contains data indexed by time in the definition of <code>mk</code>, this function requires that said data must be indexable at the future indices <code>n + 1, n + 2, ..., n + size(st, 1)</code> at which predictions are requested.  (otherwise a bounds error is thrown if bounds checking is not disabled in the definition of <code>mk</code> by the user)</p><p>To this end, the Julia package <code>OffsetArrays.jl</code> offers convenient ways of defining arrays whose indexing may be offset by <code>n</code> (upon construction of <code>newmodel</code>). See <code>predict</code> for allocating versions of this function.</p><p>REQUIRES: <code>mk</code> and <code>gk</code> from the GenericSSMs interface (see <code>?GenericSSM</code>), depending on the value of <code>L</code>.</p></div></section></article><p>The prediction results can then be obtained from the <code>PredictStorage</code> object written to.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="interface.html">« Defining SSMs using GenericSSMs.jl</a><a class="docs-footer-nextpage" href="examples.html">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 19 December 2022 16:45">Monday 19 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
